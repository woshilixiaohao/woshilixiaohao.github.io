<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="什么是unsafe #  众所周知，Go语言被设计成一门强类型的静态语言，那么他的类型就不能改变了，静态也是意味着类型检查在运行前就做了。所以在Go语言中是不允许两个指针类型进行转换的，使用过C语言的朋友应该知道这在C语言中是可以实现的，Go中不允许这么使用是处于安全考虑，毕竟强制转型会引起各种各样的麻烦，有时这些麻烦很容易被察觉，有时他们却又隐藏极深，难以察觉。大多数读者可能不明白为什么类型转换是不安全的，这里用C语言举一个简单的例子：
int main(){ double pi = 3.1415926; double *pv = &amp;pi; void *temp = pd; int *p = temp; } 在标准C语言中，任何非void类型的指针都可以和void类型的指针相互指派，也可以通过void类型指针作为中介，实现不同类型的指针间接相互转换。上面示例中，指针pv指向的空间本是一个双精度数据，占8个字节，但是经过转换后，p指向的是一个4字节的int类型。这种发生内存截断的设计缺陷会在转换后进行内存访问是存在安全隐患。我想这就是Go语言被设计成强类型语言的原因之一吧。
虽然类型转换是不安全的，但是在一些特殊场景下，使用了它，可以打破Go的类型和内存安全机制，可以绕过类型系统低效，提高运行效率。所以Go标准库中提供了一个unsafe包，之所以叫这个名字，就是不推荐大家使用，但是不是不能用，如果你掌握的特别好，还是可以实践的。
unsafe 实现原理 #  在使用之前我们先来看一下unsafe的源码部分，标准库unsafe包中只提供了3``种方法，分别是:
func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr  Sizeof(x ArbitrayType)方法主要作用是用返回类型x所占据的字节数，但并不包含x所指向的内容的大小，与C语言标准库中的Sizeof()方法功能一样，比如在32位机器上，一个指针返回大小就是4字节。 Offsetof(x ArbitraryType)方法主要作用是返回结构体成员在内存中的位置离结构体起始处(结构体的第一个字段的偏移量都是0)的字节数，即偏移量，我们在注释中看一看到其入参必须是一个结构体，其返回值是一个常量。 Alignof(x ArbitratyType)的主要作用是返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。一般对齐值是2^n，最大不会超过8(受内存对齐影响).获取对齐值还可以使用反射包的函数，也就是说：unsafe.Alignof(x)等价于reflect.TypeOf(x).Align()。对于任意类型的变量x，unsafe.Alignof(x)至少为1。对于struct结构体类型的变量x，计算x每一个字段f的unsafe.Alignof(x，f)，unsafe.Alignof(x)等于其中的最大值。对于array数组类型的变量x，unsafe.Alignof(x)等于构成数组的元素类型的对齐倍数。没有任何字段的空struct{}和没有任何元素的array占据的内存空间大小为0，不同大小为0的变量可能指向同一块地址。  细心的朋友会发发现这三个方法返回的都是uintptr类型，这个目的就是可以和unsafe.poniter类型相互转换，因为*T是不能计算偏移量的，也不能进行计算，但是uintptr是可以的，所以可以使用uintptr类型进行计算，这样就可以可以访问特定的内存了，达到对不同的内存读写的目的。三个方法的入参都是ArbitraryType类型，代表着任意类型的意思，同时还提供了一个Pointer指针类型，即像void *一样的通用型指针。
type ArbitraryType int type Pointer *ArbitraryType // uintptr 是一个整数类型，它足够大，可以存储 type uintptr uintptr 上面说了这么多，可能会有点懵，在这里对三种指针类型做一个总结：
 *T：普通类型指针类型，用于传递对象地址，不能进行指针运算。 unsafe.poniter：通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值(需转换到某一类型的普通指针) uintptr：用于指针运算，GC不把uintptr当指针，uintptr无法持有对象。uintptr类型的目标会被回收。  三者关系就是：unsafe.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="什么是unsafe #  众所周知，Go语言被设计成一门强类型的静态语言，那么他的类型就不能改变了，静态也是意味着类型检查在运行前就做了。所以在Go语言中是不允许两个指针类型进行转换的，使用过C语言的朋友应该知道这在C语言中是可以实现的，Go中不允许这么使用是处于安全考虑，毕竟强制转型会引起各种各样的麻烦，有时这些麻烦很容易被察觉，有时他们却又隐藏极深，难以察觉。大多数读者可能不明白为什么类型转换是不安全的，这里用C语言举一个简单的例子：
int main(){ double pi = 3.1415926; double *pv = &amp;pi; void *temp = pd; int *p = temp; } 在标准C语言中，任何非void类型的指针都可以和void类型的指针相互指派，也可以通过void类型指针作为中介，实现不同类型的指针间接相互转换。上面示例中，指针pv指向的空间本是一个双精度数据，占8个字节，但是经过转换后，p指向的是一个4字节的int类型。这种发生内存截断的设计缺陷会在转换后进行内存访问是存在安全隐患。我想这就是Go语言被设计成强类型语言的原因之一吧。
虽然类型转换是不安全的，但是在一些特殊场景下，使用了它，可以打破Go的类型和内存安全机制，可以绕过类型系统低效，提高运行效率。所以Go标准库中提供了一个unsafe包，之所以叫这个名字，就是不推荐大家使用，但是不是不能用，如果你掌握的特别好，还是可以实践的。
unsafe 实现原理 #  在使用之前我们先来看一下unsafe的源码部分，标准库unsafe包中只提供了3``种方法，分别是:
func Sizeof(x ArbitraryType) uintptr func Offsetof(x ArbitraryType) uintptr func Alignof(x ArbitraryType) uintptr  Sizeof(x ArbitrayType)方法主要作用是用返回类型x所占据的字节数，但并不包含x所指向的内容的大小，与C语言标准库中的Sizeof()方法功能一样，比如在32位机器上，一个指针返回大小就是4字节。 Offsetof(x ArbitraryType)方法主要作用是返回结构体成员在内存中的位置离结构体起始处(结构体的第一个字段的偏移量都是0)的字节数，即偏移量，我们在注释中看一看到其入参必须是一个结构体，其返回值是一个常量。 Alignof(x ArbitratyType)的主要作用是返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。一般对齐值是2^n，最大不会超过8(受内存对齐影响).获取对齐值还可以使用反射包的函数，也就是说：unsafe.Alignof(x)等价于reflect.TypeOf(x).Align()。对于任意类型的变量x，unsafe.Alignof(x)至少为1。对于struct结构体类型的变量x，计算x每一个字段f的unsafe.Alignof(x，f)，unsafe.Alignof(x)等于其中的最大值。对于array数组类型的变量x，unsafe.Alignof(x)等于构成数组的元素类型的对齐倍数。没有任何字段的空struct{}和没有任何元素的array占据的内存空间大小为0，不同大小为0的变量可能指向同一块地址。  细心的朋友会发发现这三个方法返回的都是uintptr类型，这个目的就是可以和unsafe.poniter类型相互转换，因为*T是不能计算偏移量的，也不能进行计算，但是uintptr是可以的，所以可以使用uintptr类型进行计算，这样就可以可以访问特定的内存了，达到对不同的内存读写的目的。三个方法的入参都是ArbitraryType类型，代表着任意类型的意思，同时还提供了一个Pointer指针类型，即像void *一样的通用型指针。
type ArbitraryType int type Pointer *ArbitraryType // uintptr 是一个整数类型，它足够大，可以存储 type uintptr uintptr 上面说了这么多，可能会有点懵，在这里对三种指针类型做一个总结：
 *T：普通类型指针类型，用于传递对象地址，不能进行指针运算。 unsafe.poniter：通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值(需转换到某一类型的普通指针) uintptr：用于指针运算，GC不把uintptr当指针，uintptr无法持有对象。uintptr类型的目标会被回收。  三者关系就是：unsafe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://woshilixiaohao.github.io/docs/tech/go/unsafe%E5%8C%85/" /><meta property="article:section" content="docs" />



<title>Unsafe包 | 老三炮的笔记</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css" integrity="sha256-RhgbyTN1upMgJudTs3xA5v&#43;LsWqe93DHi8xmPkV3sbo=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.55521e020be85709ff7a38b6c916ae95096e8bcaa216ac4aaaff69e27781036c.js" integrity="sha256-VVIeAgvoVwn/eji2yRaulQlui8qiFqxKqv9p4neBA2w=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>老三炮的笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/interview/" class="">Interview</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">Mysql面试题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/interview/redis%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">Redis面试题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/" class="">Tech</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/db/" class="">Db</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/db/mysql/" class="">Mysql</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/go/" class="">Go</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/go/atomic%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="">Atomic包源码解析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" class="">Golang内存分配</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/go/go%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">Go常用设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/go/unsafe%E5%8C%85/" class=" active">Unsafe包</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/java/" class="">Java</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/java/java-test/" class="">Java Test</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/mq/" class="">Mq</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/mq/kafka/" class="">Kafka</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/nosql/" class="">Nosql</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/nosql/elasticsearch/" class="">Elasticsearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="https://woshilixiaohao.github.io/docs/tech/nosql/redis/" class="">Redis</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Unsafe包</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#什么是unsafe">什么是<code>unsafe</code></a></li>
    <li><a href="#unsafe-实现原理"><code>unsafe</code> 实现原理</a></li>
    <li><a href="#unsafepointer基本使用"><code>unsafe.Pointer</code>基本使用</a></li>
    <li><a href="#sizeofalignofoffsetof三个函数的基本使用"><code>Sizeof、Alignof、Offsetof</code>三个函数的基本使用</a></li>
    <li><a href="#经典应用string与byte的相互转换">经典应用：string与[]byte的相互转换</a></li>
    <li><a href="#内存对齐">内存对齐</a></li>
    <li><a href="#总结">总结</a>
      <ul>
        <li><a href="#由go-看源码必会知识之-unsafe-包-qqcomhttpsmpweixinqqcomswdfdpv3bdnhy5pc8kl6w6w-转载">由<a href="https://mp.weixin.qq.com/s/wdFdPv3Bdnhy5pc8KL6w6w">Go 看源码必会知识之 unsafe 包 (qq.com)</a> 转载</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="什么是unsafe">
  什么是<code>unsafe</code>
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afunsafe">#</a>
</h2>
<p>众所周知，<code>Go语言</code>被设计成一门强类型的静态语言，那么他的类型就不能改变了，静态也是意味着类型检查在运行前就做了。所以在<code>Go</code>语言中是不允许两个指针类型进行转换的，使用过<code>C</code>语言的朋友应该知道这在<code>C</code>语言中是可以实现的，<code>Go</code>中不允许这么使用是处于安全考虑，毕竟强制转型会引起各种各样的麻烦，有时这些麻烦很容易被察觉，有时他们却又隐藏极深，难以察觉。大多数读者可能不明白为什么类型转换是不安全的，这里用<code>C</code>语言举一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
  <span style="color:#66d9ef">double</span> pi <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.1415926</span>;
  <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>pv <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>pi;
  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> pd;
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> temp;
}
</code></pre></div><p>在标准<code>C语言</code>中，任何非<code>void</code>类型的指针都可以和<code>void</code>类型的指针相互指派，也可以通过<code>void</code>类型指针作为中介，实现不同类型的指针间接相互转换。上面示例中，指针<code>pv</code>指向的空间本是一个双精度数据，占<code>8</code>个字节，但是经过转换后，<code>p</code>指向的是一个<code>4</code>字节的<code>int</code>类型。这种发生内存截断的设计缺陷会在转换后进行内存访问是存在安全隐患。我想这就是<code>Go</code>语言被设计成强类型语言的原因之一吧。</p>
<p>虽然类型转换是不安全的，但是在一些特殊场景下，使用了它，可以打破<code>Go</code>的类型和内存安全机制，可以绕过类型系统低效，提高运行效率。所以<code>Go</code>标准库中提供了一个<code>unsafe</code>包，之所以叫这个名字，就是不推荐大家使用，但是不是不能用，如果你掌握的特别好，还是可以实践的。</p>
<h2 id="unsafe-实现原理">
  <code>unsafe</code> 实现原理
  <a class="anchor" href="#unsafe-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h2>
<p>在使用之前我们先来看一下<code>unsafe</code>的源码部分，标准库<code>unsafe</code>包中只提供了<code>3``种</code>方法，分别是:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
</code></pre></div><ul>
<li><code>Sizeof(x ArbitrayType)</code>方法主要作用是用返回类型<code>x</code>所占据的字节数，但并不包含<code>x</code>所指向的内容的大小，与<code>C</code>语言标准库中的<code>Sizeof()</code>方法功能一样，比如在<code>32</code>位机器上，一个指针返回大小就是4字节。</li>
<li><code>Offsetof(x ArbitraryType)</code>方法主要作用是返回结构体成员在内存中的位置离结构体起始处(结构体的第一个字段的偏移量都是0)的字节数，即偏移量，我们在注释中看一看到其入参必须是一个结构体，其返回值是一个常量。</li>
<li><code>Alignof(x ArbitratyType)</code>的主要作用是返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能。一般对齐值是<code>2^n</code>，最大不会超过<code>8</code>(受内存对齐影响).获取对齐值还可以使用反射包的函数，也就是说：<code>unsafe.Alignof(x)</code>等价于<code>reflect.TypeOf(x).Align()</code>。对于任意类型的变量<code>x</code>，<code>unsafe.Alignof(x)</code>至少为1。对于<code>struct</code>结构体类型的变量<code>x</code>，计算<code>x</code>每一个字段<code>f</code>的<code>unsafe.Alignof(x，f)</code>，<code>unsafe.Alignof(x)</code>等于其中的最大值。对于<code>array</code>数组类型的变量<code>x</code>，<code>unsafe.Alignof(x)</code>等于构成数组的元素类型的对齐倍数。没有任何字段的空<code>struct{}</code>和没有任何元素的<code>array</code>占据的内存空间大小为<code>0</code>，不同大小为<code>0</code>的变量可能指向同一块地址。</li>
</ul>
<p>细心的朋友会发发现这三个方法返回的都是<code>uintptr</code>类型，这个目的就是可以和<code>unsafe.poniter</code>类型相互转换，因为<code>*T</code>是不能计算偏移量的，也不能进行计算，但是<code>uintptr</code>是可以的，所以可以使用<code>uintptr</code>类型进行计算，这样就可以可以访问特定的内存了，达到对不同的内存读写的目的。三个方法的入参都是<code>ArbitraryType</code>类型，代表着任意类型的意思，同时还提供了一个<code>Pointer</code>指针类型，即像<code>void *</code>一样的通用型指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ArbitraryType</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pointer</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ArbitraryType</span>
<span style="color:#75715e">// uintptr 是一个整数类型，它足够大，可以存储
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#66d9ef">uintptr</span>
</code></pre></div><p>上面说了这么多，可能会有点懵，在这里对三种指针类型做一个总结：</p>
<ul>
<li><code>*T</code>：普通类型指针类型，用于传递对象地址，不能进行指针运算。</li>
<li><code>unsafe.poniter</code>：通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值(需转换到某一类型的普通指针)</li>
<li><code>uintptr</code>：用于指针运算，<code>GC</code>不把<code>uintptr</code>当指针，<code>uintptr</code>无法持有对象。<code>uintptr</code>类型的目标会被回收。</li>
</ul>
<p>三者关系就是：<code>unsafe.Pointer</code>是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为<code>uintptr</code>进行指针运算，也就说<code>uintptr</code>是用来与<code>unsafe.Pointer</code>打配合，用于指针运算。画个图表示一下：</p>
<p>
  <img src="https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPOmeloVMhYTE90Qx3uiaiaCRqDbeNJBbLaQ0PVBC4j50TjW5puiaBpZbPic5YokUHkSK2fvUricoE17trQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>基本原理就说到这里啦，接下来我们一起来看看如何使用~</p>
<h2 id="unsafepointer基本使用">
  <code>unsafe.Pointer</code>基本使用
  <a class="anchor" href="#unsafepointer%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8">#</a>
</h2>
<p>我们在上一篇分析
  <a href="https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;mid=2247484475&amp;idx=1&amp;sn=f470d42fee8b9b65fad7b43e57518cfc&amp;scene=21#wechat_redirect"><code>atomic.Value</code>源码时</a>，看到<code>atomic/value.go</code>中定义了一个<code>ifaceWords</code>结构，其中<code>typ</code>和<code>data</code>字段类型就是<code>unsafe.Poniter</code>，这里使用<code>unsafe.Poniter</code>类型的原因是传入的值就是<code>interface{}</code>类型，使用<code>unsafe.Pointer</code>强转成<code>ifaceWords</code>类型，这样可以把类型和值都保存了下来，方便后面的写入类型检查。截取部分代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// ifaceWords is interface{} internal representation.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ifaceWords</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">typ</span>  <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
 <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
}
<span style="color:#75715e">// Load returns the value set by the most recent Store.
</span><span style="color:#75715e">// It returns nil if there has been no call to Store for this Value.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Value</span>) <span style="color:#a6e22e">Load</span>() (<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{}) {
 <span style="color:#a6e22e">vp</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">ifaceWords</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">v</span>))
  <span style="color:#66d9ef">for</span> {
  <span style="color:#a6e22e">typ</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">LoadPointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">vp</span>.<span style="color:#a6e22e">typ</span>) <span style="color:#75715e">// 读取已经存在值的类型
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">    ..... 中间省略
</span><span style="color:#75715e">    **/</span>
    <span style="color:#75715e">// First store completed. Check type and overwrite data.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">typ</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">xp</span>.<span style="color:#a6e22e">typ</span> { <span style="color:#75715e">//当前类型与要存入的类型做对比
</span><span style="color:#75715e"></span>   panic(<span style="color:#e6db74">&#34;sync/atomic: store of inconsistently typed value into Value&#34;</span>)
  }
}
</code></pre></div><p>上面就是源码中使用<code>unsafe.Pointer</code>的一个例子，有一天当你准备读源码时，<code>unsafe.pointer</code>的使用到处可见。好啦，接下来我们写一个简单的例子，看看<code>unsafe.Pointer</code>是如何使用的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()  {
 <span style="color:#a6e22e">number</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
 <span style="color:#a6e22e">pointer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">number</span>
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;number:addr:%p, value:%d\n&#34;</span>,<span style="color:#a6e22e">pointer</span>,<span style="color:#f92672">*</span><span style="color:#a6e22e">pointer</span>)

 <span style="color:#a6e22e">float32Number</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">float32</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">pointer</span>))
 <span style="color:#f92672">*</span><span style="color:#a6e22e">float32Number</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">float32Number</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>

 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;float64:addr:%p, value:%f\n&#34;</span>,<span style="color:#a6e22e">float32Number</span>,<span style="color:#f92672">*</span><span style="color:#a6e22e">float32Number</span>)
}
</code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">number</span>:<span style="color:#a6e22e">addr</span>:<span style="color:#ae81ff">0xc000018090</span>, <span style="color:#a6e22e">value</span>:<span style="color:#ae81ff">5</span>
<span style="color:#66d9ef">float64</span>:<span style="color:#a6e22e">addr</span>:<span style="color:#ae81ff">0xc000018090</span>, <span style="color:#a6e22e">value</span>:<span style="color:#ae81ff">3.000000</span>
</code></pre></div><p>由运行可知使用<code>unsafe.Pointer</code>强制类型转换后指针指向的地址是没有改变，只是类型发生了改变。这个例子本身没什么意义，正常项目中也不会这样使用。</p>
<p>总结一下基本使用：先把<code>*T</code>类型转换成<code>unsafe.Pointer</code>类型，然后在进行强制转换转成你需要的指针类型即可。</p>
<h2 id="sizeofalignofoffsetof三个函数的基本使用">
  <code>Sizeof、Alignof、Offsetof</code>三个函数的基本使用
  <a class="anchor" href="#sizeofalignofoffsetof%e4%b8%89%e4%b8%aa%e5%87%bd%e6%95%b0%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8">#</a>
</h2>
<p>先看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
 <span style="color:#a6e22e">Age</span> <span style="color:#66d9ef">uint32</span>
 <span style="color:#a6e22e">Gender</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// 男:true 女：false 就是举个例子别吐槽我这么用。。。。
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">func_example</span>()  {
 <span style="color:#75715e">// sizeof
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#66d9ef">true</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(int8(<span style="color:#ae81ff">0</span>)))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(int16(<span style="color:#ae81ff">10</span>)))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(int(<span style="color:#ae81ff">10</span>)))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(int32(<span style="color:#ae81ff">190</span>)))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#e6db74">&#34;asong&#34;</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>([]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>}))
 <span style="color:#75715e">// Offsetof
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">User</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;Asong&#34;</span>, <span style="color:#a6e22e">Age</span>: <span style="color:#ae81ff">23</span>,<span style="color:#a6e22e">Gender</span>: <span style="color:#66d9ef">true</span>}
 <span style="color:#a6e22e">userNamePointer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">user</span>)

 <span style="color:#a6e22e">nNamePointer</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">userNamePointer</span>))
 <span style="color:#f92672">*</span><span style="color:#a6e22e">nNamePointer</span> = <span style="color:#e6db74">&#34;Golang梦工厂&#34;</span>

 <span style="color:#a6e22e">nAgePointer</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint32</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(uintptr(<span style="color:#a6e22e">userNamePointer</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Age</span>)))
 <span style="color:#f92672">*</span><span style="color:#a6e22e">nAgePointer</span> = <span style="color:#ae81ff">25</span>

 <span style="color:#a6e22e">nGender</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">bool</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(uintptr(<span style="color:#a6e22e">userNamePointer</span>)<span style="color:#f92672">+</span><span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Gender</span>)))
 <span style="color:#f92672">*</span><span style="color:#a6e22e">nGender</span> = <span style="color:#66d9ef">false</span>

 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;u.Name: %s, u.Age: %d,  u.Gender: %v\n&#34;</span>, <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Age</span>,<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Gender</span>)
 <span style="color:#75715e">// Alignof
</span><span style="color:#75715e"></span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i8</span> <span style="color:#66d9ef">int8</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i16</span> <span style="color:#66d9ef">int16</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i64</span> <span style="color:#66d9ef">int64</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f32</span> <span style="color:#66d9ef">float32</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int32</span>

 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">b</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">i8</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">i16</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">i64</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">f32</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">s</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">m</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">p</span>))
}
</code></pre></div><p>为了省事，把三个函数的使用示例放到了一起，首先看<code>sizeof</code>方法，我们可以知道各个类型所占字节大小，这里重点说一下<code>int</code>类型，<code>Go语言</code>中的<code>int</code>类型的具体大小是跟机器的 <code>CPU</code>位数相关的。如果 <code>CPU</code> 是<code>32</code> 位的，那么<code>int</code>就占<code>4</code>字节，如果 <code>CPU</code>是<code>64</code>位的，那么 <code>int</code> 就占<code>8</code> 字节，这里我的电脑是<code>64位的</code>，所以结果就是<code>8</code>字节。</p>
<p>然后我们在看<code>Offsetof</code>函数，我想要修改结构体中成员变量，第一个成员变量是不需要进行偏移量计算的，直接取出指针后转换为<code>unsafe.pointer</code>，在强制给他转换成字符串类型的指针值即可。如果要修改其他成员变量，需要进行偏移量计算，才可以对其内存地址修改，所以<code>Offsetof</code>方法就可返回成员变量在结构体中的偏移量，也就是返回结构体初始位置到成员变量之间的字节数。看代码时大家应该要住<code>uintptr</code>的使用，不可以用一个临时变量存储<code>uintptr</code>类型，前面我们提到过用于指针运算，<code>GC</code>不把<code>uintptr</code>当指针，<code>uintptr</code>无法持有对象。<code>uintptr</code>类型的目标会被回收，所以你不知道他什么时候会被<code>GC</code>掉，那样接下来的内存操作会发生什么样的错误，咱也不知道。比如这样一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 切记不要这样使用
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p1</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">userNamePointer</span>)
<span style="color:#a6e22e">nAgePointer</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint32</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">p1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Age</span>)))
</code></pre></div><p>最后看一下<code>Alignof</code>函数，主要是获取变量的对齐值，除了<code>int、uintptr</code>这些依赖<code>CPU</code>位数的类型，基本类型的对齐值都是固定的，结构体中对齐值取他的成员对齐值的最大值，结构体的对齐涉及到内存对齐，我们在下面详细介绍。</p>
<h2 id="经典应用string与byte的相互转换">
  经典应用：string与[]byte的相互转换
  <a class="anchor" href="#%e7%bb%8f%e5%85%b8%e5%ba%94%e7%94%a8string%e4%b8%8ebyte%e7%9a%84%e7%9b%b8%e4%ba%92%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>实现<code>string</code>与<code>byte</code>的转换，正常情况下，我们可能会写出这样的标准转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// string to []byte
</span><span style="color:#75715e"></span><span style="color:#a6e22e">str1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;Golang梦工厂&#34;</span>
<span style="color:#a6e22e">by</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">s1</span>)

<span style="color:#75715e">// []byte to string
</span><span style="color:#75715e"></span><span style="color:#a6e22e">str2</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">by</span>)
</code></pre></div><p>使用这种方式进行转换都会涉及底层数值的拷贝，所以想要实现零拷贝，我们可以使用<code>unsafe.Pointer</code>来实现，通过强转换直接完成指针的指向，从而使<code>string</code>和<code>[]byte</code>指向同一个底层数据。在<code>reflect</code>包中有·<code>string</code>和<code>slice</code>对应的结构体，他们的分别是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringHeader</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">uintptr</span>
 <span style="color:#a6e22e">Len</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceHeader</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">uintptr</span>
 <span style="color:#a6e22e">Len</span>  <span style="color:#66d9ef">int</span>
 <span style="color:#a6e22e">Cap</span>  <span style="color:#66d9ef">int</span>
}
</code></pre></div><p><code>StringHeader</code>代表的是<code>string</code>运行时的表现形式(SliceHeader同理)，通过对比<code>string</code>和<code>slice</code>运行时的表达可以看出，他们只有一个<code>Cap</code>字段不同，所以他们的内存布局是对齐的，所以可以通过<code>unsafe.Pointer</code>进行转换，因为可以写出如下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stringToByte</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">byte</span> {
 <span style="color:#a6e22e">header</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">StringHeader</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))

 <span style="color:#a6e22e">newHeader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">SliceHeader</span>{
  <span style="color:#a6e22e">Data</span>: <span style="color:#a6e22e">header</span>.<span style="color:#a6e22e">Data</span>,
  <span style="color:#a6e22e">Len</span>:  <span style="color:#a6e22e">header</span>.<span style="color:#a6e22e">Len</span>,
  <span style="color:#a6e22e">Cap</span>:  <span style="color:#a6e22e">header</span>.<span style="color:#a6e22e">Len</span>,
 }

 <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>[]<span style="color:#66d9ef">byte</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newHeader</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bytesToString</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">string</span>{
 <span style="color:#a6e22e">header</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">SliceHeader</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>))

 <span style="color:#a6e22e">newHeader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">StringHeader</span>{
  <span style="color:#a6e22e">Data</span>: <span style="color:#a6e22e">header</span>.<span style="color:#a6e22e">Data</span>,
  <span style="color:#a6e22e">Len</span>:  <span style="color:#a6e22e">header</span>.<span style="color:#a6e22e">Len</span>,
 }

 <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newHeader</span>))
}
</code></pre></div><p>上面的代码我们通过重新构造<code>slice header</code>和<code>string header</code>完成了类型转换，其实<code>[]byte</code>转换成<code>string</code>可以省略掉自己构造<code>StringHeader</code>的方式，直接使用强转就可以，因为<code>string</code>的底层也是<code>[]byte</code>，强转会自动构造，省略后的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bytesToString</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">string</span> {
 <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span> <span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>))
}
</code></pre></div><p>虽然这种方式更高效率，但是不推荐大家使用，前面也提高到了，这要是不安全的，使用当不当会出现极大的隐患，一些严重的情况<code>recover</code>也不能捕获。</p>
<h2 id="内存对齐">
  内存对齐
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90">#</a>
</h2>
<p>现在计算机中内存空间都是按照<code>byte</code>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就对齐。</p>
<p>对齐的作用和原因：<code>CPU</code>访问内存时，并不是逐个字节访问，而是以字长（<code>word size</code>)单位访问。比如<code>32</code>位的<code>CPU</code>，字长为<code>4</code>字节，那么<code>CPU</code>访问内存的单位也是<code>4</code>字节。这样设计可以减少<code>CPU</code>访问内存的次数，加大<code>CPU</code>访问内存的吞吐量。假设我们需要读取8个字节的数据，一次读取<code>4</code>个字节那么就只需读取<code>2</code>次就可以。内存对齐对实现变量的原子性操作也是有好处的，每次内存访问都是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。</p>
<p>我们来看这样一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 64位平台，对齐参数是8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User1</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int32</span> <span style="color:#75715e">// 4 
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">B</span> []<span style="color:#66d9ef">int32</span> <span style="color:#75715e">// 24 
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">string</span> <span style="color:#75715e">// 16 
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// 1 
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User2</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">B</span> []<span style="color:#66d9ef">int32</span>
 <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int32</span>
 <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">bool</span>
 <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">User3</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">bool</span>
 <span style="color:#a6e22e">B</span> []<span style="color:#66d9ef">int32</span>
 <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int32</span>
 <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">string</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()  {
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u1</span> <span style="color:#a6e22e">User1</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u2</span> <span style="color:#a6e22e">User2</span>
 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u3</span> <span style="color:#a6e22e">User3</span>

 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;u1 size is &#34;</span>,<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">u1</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;u2 size is &#34;</span>,<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">u2</span>))
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;u3 size is &#34;</span>,<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">u3</span>))
}
<span style="color:#75715e">// 运行结果 MAC: 64位
</span><span style="color:#75715e"></span><span style="color:#a6e22e">u1</span> <span style="color:#a6e22e">size</span> <span style="color:#a6e22e">is</span>  <span style="color:#ae81ff">56</span>
<span style="color:#a6e22e">u2</span> <span style="color:#a6e22e">size</span> <span style="color:#a6e22e">is</span>  <span style="color:#ae81ff">48</span>
<span style="color:#a6e22e">u3</span> <span style="color:#a6e22e">size</span> <span style="color:#a6e22e">is</span>  <span style="color:#ae81ff">56</span>
</code></pre></div><p>从结果可以看出，字段放置不同的顺序，占用内存也不一样，这就是因为内存对齐影响了<code>struct</code>的大小，所以有时候合理的字段可以减少内存的开销。下面我们就一起来分析一下内存对齐，首先要明白什么是内存对齐的规则，<code>C语言</code>的对齐规则与<code>Go</code>语言一样，所以<code>C语言</code>的对齐规则对<code>Go</code>同样适用：</p>
<ul>
<li>对于结构的各个成员，第一个成员位于偏移为0的位置，结构体第一个成员的<strong>偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li>除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。</li>
</ul>
<p>好啦，知道规则了，我们现在来分析一下上面的例子，根据我的<code>mac</code>使用的64位<code>CPU</code>,对齐参数是8来分析，<code>int32</code>、<code>[]int32</code>、<code>string</code>、<code>bool</code>对齐值分别是<code>4</code>、<code>8</code>、<code>8</code>、<code>1</code>，占用内存大小分别是<code>4</code>、<code>24</code>、<code>16</code>、<code>1</code>，我们先根据第一条对齐规则分析<code>User1</code>：</p>
<ul>
<li>第一个字段类型是<code>int32</code>，对齐值是4，大小为4，所以放在内存布局中的第一位.</li>
<li>第二个字段类型是<code>[]int32</code>，对齐值是8，大小为24，所以他的内存偏移值必须是8的倍数，所以在当前<code>user1</code>中，就不能从第<code>4</code>位开始了，必须从第<code>5</code>位开始，也就偏移量为<code>8</code>。第<code>4,5,6,7</code>位由编译器进行填充，一般为<code>0</code>值，也称之为空洞。第<code>9</code>位到第<code>32</code>位为第二个字段<code>B</code>.</li>
<li>第三个字段类型是<code>string</code>，对齐值是<code>8</code>，大小为<code>16</code>，所以他的内存偏移值必须是8的倍数，因为<code>user1</code>前两个字段就已经排到了第<code>32</code>位，所以下一位的偏移量正好是<code>32</code>，正好是字段<code>C</code>的对齐值的倍数，不用填充，可以直接排列第三个字段，也就是从第<code>32</code>位到<code>48</code>位第三个字段<code>C</code>.</li>
<li>第三个字段类型是<code>bool</code>，对齐值是<code>1</code>，大小为<code>1</code>，所以他的内存偏移值必须是<code>1</code>的倍数，因为<code>user1</code>前两个字段就已经排到了第<code>48</code>位，所以下一位的偏移量正好是<code>48</code>。正好是字段<code>D</code>的对齐值的倍数，不用填充，可以直接排列到第四个字段，也就是从<code>48</code>到第<code>49</code>位是第三个字段<code>D</code>.</li>
<li>好了现在第一条内存对齐规则后，内存长度已经为<code>49</code>字节，我们开始使用内存的第<code>2</code>条规则进行对齐。根据第二条规则，默认对齐值是<code>8</code>，字段中最大类型程度是<code>24</code>，取最小的那一个，所以求出结构体的对齐值是<code>8</code>，我们目前的内存长度是<code>49</code>，不是<code>8</code>的倍数，所以需要补齐，所以最终的结果就是<code>56</code>，补了<code>7</code>位。</li>
</ul>
<p>说了这么多，画个图看一下吧：</p>
<p>
  <img src="https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPOmeloVMhYTE90Qx3uiaiaCRqxRib3u2JXgrOCUFyTEql0NRbQ0t5Wib03ibkgiaojWOsYFXzOibVhflVqJw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>现在你们应该懂了吧，按照这个思路再去分析其他两个<code>struct</code>吧，这里就不再分析了。</p>
<p>对于内存对齐这里还有一最后需要注意的知识点，空<code>struct</code>不占用任何存储空间，空 <code>struct{}</code> 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 <code>struct{}</code> 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。来看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>()  {
 <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">test1</span>{})) <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">test2</span>{})) <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test1</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int32</span>
 <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">struct</span>{}
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test2</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">struct</span>{}
 <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int32</span>
}
</code></pre></div><p>简单来说，对于任何占用0大小空间的类型，像<code>struct {}</code>或者<code>[0]byte</code>这些，如果该类型出现在结构体末尾，那么我们就假设它占用1个字节的大小。因此对于<code>test1</code>结构体，他看起来就是这样：`</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test1</span> <span style="color:#66d9ef">struct</span> {
 <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int32</span>
<span style="color:#75715e">// b struct{}
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">b</span> [<span style="color:#ae81ff">1</span>]<span style="color:#66d9ef">byte</span>
}
</code></pre></div><p>因此在内存对齐时，最后结构体占用的字节就是8了。</p>
<p><strong>重点要注意的问题：不要在结构体定义的最后添加零大小的类型</strong></p>
<h2 id="总结">
  总结
  <a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a>
</h2>
<p>好啦，终于又到文章的末尾了，我们来简单的总结一下，unsafe 包绕过了 Go 的类型系统，达到直接操作内存的目的，使用它有一定的风险性。但是在某些场景下，使用 unsafe 包提供的函数会提升代码的效率，Go 源码中也是大量使用 unsafe 包。</p>
<p>unsafe 包定义了 Pointer 和三个函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ArbitraryType</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Pointer</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ArbitraryType</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">ArbitraryType</span>) <span style="color:#66d9ef">uintptr</span>
</code></pre></div><p>uintptr 可以和 unsafe.Pointer 进行相互转换，uintptr 可以进行数学运算。这样，通过 uintptr 和 unsafe.Pointer 的结合就解决了 Go 指针不能进行数学运算的限制。通过 unsafe 相关函数，可以获取结构体私有成员的地址，进而对其做进一步的读写操作，突破 Go 的类型安全限制。</p>
<p>最后我们又学习了<code>内存对齐</code>的知识，这样设计可以减少<code>CPU</code>访问内存的次数，加大<code>CPU</code>访问内存的吞吐量，所以结构体中字段合理的排序可以更节省内存，注意：不要在结构体定义的最后添加零大小的类型。</p>
由<h3 id="由go-看源码必会知识之-unsafe-包-qqcomhttpsmpweixinqqcomswdfdpv3bdnhy5pc8kl6w6w-转载">
  
  <a href="https://mp.weixin.qq.com/s/wdFdPv3Bdnhy5pc8KL6w6w">Go 看源码必会知识之 unsafe 包 (qq.com)</a> 转载
  <a class="anchor" href="#%e7%94%b1go-%e7%9c%8b%e6%ba%90%e7%a0%81%e5%bf%85%e4%bc%9a%e7%9f%a5%e8%af%86%e4%b9%8b-unsafe-%e5%8c%85-qqcomhttpsmpweixinqqcomswdfdpv3bdnhy5pc8kl6w6w-%e8%bd%ac%e8%bd%bd">#</a>
</h3>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#什么是unsafe">什么是<code>unsafe</code></a></li>
    <li><a href="#unsafe-实现原理"><code>unsafe</code> 实现原理</a></li>
    <li><a href="#unsafepointer基本使用"><code>unsafe.Pointer</code>基本使用</a></li>
    <li><a href="#sizeofalignofoffsetof三个函数的基本使用"><code>Sizeof、Alignof、Offsetof</code>三个函数的基本使用</a></li>
    <li><a href="#经典应用string与byte的相互转换">经典应用：string与[]byte的相互转换</a></li>
    <li><a href="#内存对齐">内存对齐</a></li>
    <li><a href="#总结">总结</a>
      <ul>
        <li><a href="#由go-看源码必会知识之-unsafe-包-qqcomhttpsmpweixinqqcomswdfdpv3bdnhy5pc8kl6w6w-转载">由<a href="https://mp.weixin.qq.com/s/wdFdPv3Bdnhy5pc8KL6w6w">Go 看源码必会知识之 unsafe 包 (qq.com)</a> 转载</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












